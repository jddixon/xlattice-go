<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>xlReg_protocol</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/normalize.css" />
  <link rel="stylesheet" type="text/css" href="css/ghp.css" />
</head>
<body>
<div class="content">
<h1 class="libTop">The XLReg Protocol</h1>

<h2>Registry Credentials</h2>

<p>Any XLReg server will profide credentials upon request.
These are conventionally delivered as an ASCII file, <code>regCred.dat</code>,
containing</p>

<ul>
<li>the registry&rsquo;s name</li>
<li>its ID as a string of hex digits</li>
<li>its comms RSA public key in ssh format</li>
<li>its sig RSA public key in ssh format</li>
<li>its IP address and port</li>
<li>and the xlReg protocol version it is running.</li>
</ul>

<p>An example follows.</p>

<pre><code>regCred {
    Name: xlReg
    ID: 21b95b5c697977d266a0c364e12787ad72bf6fc9346ec0edef351cfb6da90c24
    CommsPubKey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCZz5Kdt5XqLRVipmnEEu1eedHmSswP8ZDkbadkRdCrgpGm1OLe79WTrkB0HLW98pjyBooaWLU/thSoB1/2UfkaYdoDHtfHzMKBLUmfR8MCgQaKA3KoOr83wYdtLPYiUmIlg77CjUAuKOPYtd8oy+9TrbM7AwYUZf7Ps/2Lalv7JPQKHX5jyBAjs8nF9LZj+6EhYX0m6RrwyptHjTle7ajQ+6taX+9pZUIY20zu9aiR7j4LNlk2JITOPDk0mr+UsVlI6SfHpuAdy6nsG592bQLT5RF/mD5knh3/EP+b+5yXJHth8myN4UDPIIupinVQ+Vcr0H4y106bebLITWhuJiuN

    SigPubKey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDcpMhDQWgLHLcaU4Ed8fHBwLmNOa5RKECmci5VeDczF01R/VaxUcLnna58NM6m1fajNJlS3Z7xICiCwmYFOfJjQ8weuvXebqKUKTZMBghVRJqjPiWGmz9C07U/sTtRrEg0kEUZKepZ6Z9M7VN7eUJwoi+Avp99enTAKmgotYFXn47vpoLDGeKaviHAVcqOHXoQRLfT1Q6vjs/b+yg9lnxRon9kyf3tLopz64Sor6itkI0WhwdWZ0PJHDFW5SfkBhStBW1gC8vED0HO5bbi5iU1NRPiG+nUHm4UYjiQD2DY2PQGXeogZeaqL7ADy8+V0A7TYOkWZTSulK/IuYBY8Clz

    EndPoints {
         TcpEndPoint: 50.18.104.7:55555
    }
    Version: 0.4.3
}
</code></pre>

<p>This particular registry is on stockton.dixons.org, a machine in
Amazon&rsquo;s AWS/EC2 cloud.  It listens on <code>55555</code>, the port conventionally
used by the xlReg server.</p>

<p>The <code>Go</code> version of the xlReg client provides functions to read and write
serialized RegCred files (<code>xlattice_go.reg.ParseRegCred()</code> and
<code>xlattice_go.reg.String()</code> respectively.</p>

<h2>Hello and Reply</h2>

<p>All communications with the XLReg server must begin with a Hello/Reply
exchange, which verifies to the client the identity of the server and
establishes the AES IV and key used to encrypt further message
exchanges between the XLReg server and client.</p>

<h3>Version Numbers</h3>

<p>XLReg version numbers are 4-byte little-endian values.  These may be
thought of as <code>a.b.c.d</code>, where <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are unsigned byte values.
<code>d</code> is the lowest value and so will appear first in wire format.  When
serialized as strings, version numbers are conventionally written in
big-endian form, except that if the low-order fields are all zero, only
the higher-order fields appear, so <code>1.2.0.0</code> will normally be written <code>1.2</code>
(but will appear on the wire as <code>0.0.2.1</code>.  Similarly <code>1.2.3.0</code> serializes
as <code>1.2.3</code> but appears on the wire as <code>0.3.2.1</code> and <code>1.2.3.4</code> appears on
the wire as `4.3.2.1.</p>

<h3>Hello</h3>

<p>XLReg communications begin when one machine, the <strong>client</strong>,
sends a Hello message to another, the <strong>server</strong> in this context.  The
Hello message consists of</p>

<ul>
<li>a 16-byte AES initialization vector (IV)</li>
<li>a 32-byte AES key</li>
<li>an 8 byte salt (random value)</li>
<li>a 4-byte little-endian version number</li>
</ul>

<p>AES is a block cipher used for high speed encryption.  AES has a standard
block size of 16 bytes.  The key is a whole number of such blocks.  The IV is
used to set up cipher-block chaining (CBC), a mode of operation in which
each block of plaintext is XORed with the previous block of ciphertext
before encryption.  The first block of plaintext has no previous block
of ciphertext, so an IV is used instead.</p>

<p>Clients should encrypt the message using RSA-OAEP, SHA1, and a 20-byte
random value, the oaepSalt.  No label is used.  In Go this is done using</p>

<pre><code>ciphertext,err = rsa.EncryptOAEP(sha, oaepSalt, ck, data, nil)
</code></pre>

<p>where <code>sha</code> represents an instance of the SHA1 hash function and <code>ck</code> is
a pointer to an RSA public key.</p>

<p>In production all of the random values (IV, key, salt, and oaepSalt)
should be generated using a
secure, crypto-quality random number generator.</p>

<p>The Hello message is encrypted using <strong>the server&rsquo;s</strong> public key.
The message to be encoded must not be longer than the length of modulus
less twice the hash length plus 2.  As we use SHA1 the hash length is
20 bytes, so for a 1024-bit = 128 byte RSA key the maximum message length
is</p>

<pre><code>128 - (2 * 20 + 2) = 86 bytes
</code></pre>

<p>The hello message is 60 bytes long and so fits.  We recommend using 1024-bit
RSA keys for testing but 2048-bit or larger in production.</p>

<p>The Hello message is sent to the server over a TCP connection using its
well-known address.  Conventionally the xlReg server listens on port 55555.</p>

<h3>Reply</h3>

<p>The server decrypts the message using its RSA private key - and the
server&rsquo;s correctly encrypted reply proves to
the client that the server has that private key.  The server examines
the message on receipt;
if it is not well-formed the server silently discards it.  Otherwise the
server encrypts its reply using the AES IV and key from the Hello message.
The server&rsquo;s reply consists of</p>

<ul>
<li>iv2, the 16-byte IV to be used in further communications</li>
<li>key2, the 32-byte AES key to be used in such communications</li>
<li>salt2, an 8-byte random value</li>
<li>salt1, the salt from the Hello message</li>
<li>version2, a 4-byte little endian value</li>
</ul>

<p>The first three fields should be generated by a secure random number generator.</p>

<p>The version number in the Hello message is a <em>proposed</em> version number,
the version preferred by the client.  The server will reply with the
version number that it prefers, and this is the protocol version that
will be used in subsequent messages.  In this implementation the server
simply ignores the version proposed by the client.</p>

<p>If the reply from the server cannot be decoded, or if salt1 does not
match the value in the Hello message, the client should silently close
the connection.</p>

<p>Otherwise iv2 and key2 will be used in further messages between this
client and server.</p>

<h2>The Role of Protocol Buffers</h2>

<p>All xlReg client-server sessions must begin with a Hello/Reply sequence,
which establishes the identify of the server and determines the AES IV
and key used to encrypt all further messages in the session.  While the
Hello/Reply sequence is specified in terms of a pattern of bits on the
wire, ClientMsg and OKMsg are specified by a
<a href="http://github.com/golang//protobuf">Google Protocol Buffers</a>
protocol description file, <code>p.proto</code>.  This is used to generate libraries
specific to the particular language.</p>

<p>Any particular XLRegMsg message is first translated into wire format
by a Protobuf library call, then PKCS7-padded to a whole number of
16-byte AES blocks, and then AES-encrypted using the IV and key set
during the Hello/Reply sequence.  In Go this is done by a call to</p>

<pre><code>EncodePadEncrypt(msg *XLRegMsg, engine cipeher.BlockMode)
</code></pre>

<p>which returns either a byte slice or an error.</p>

<p>The receiver inverts this process.  It gets a byte slice off the wire
and makes a call to</p>

<pre><code>DecryptUnpadDecode(ciphertext []byte, engine cipher.BlockMode)
</code></pre>

<p>which returns either a pointer to an XLRegMsg or an error.</p>

<h2>XLReg Protobuf Protocol Description</h2>

<p><a href="xlReg_protobuf.html">xlReg Protobuf protocol</a></p>

<h2>Client and OK</h2>

<p>The ClientMsg, like all other XLRegMsg types, can only be sent to
the server after AES encryption is set up by the Hello/Reply sequnce.
The message descriptions that follow are expressed in terms of the
Protobuf message spec.</p>

<h3>Client Message</h3>

<p>The formal spec provides two versions of the Client message, one
containing a Token and the other only the ClientID.  At this time
only the token-based message should be used.</p>

<p>The token embedded in the client message consists of</p>

<ul>
<li>the client <strong>Name</strong>, whose leading character should be a letter; other
characters should be alphanumeric</li>
<li>an unsigned 64-bit <strong>Attrs</strong> field; this is the client&rsquo;s proposed
value (and is ignored in the current implementation)</li>
<li>a serialized RSA public key, the <strong>CommsKey</strong>, used for encrypting
(small) messages</li>
<li>another serialzied RSA public key, the <strong>SigKey</strong>, used only for
creating digital signatures</li>
<li>an array of strings, <strong>MyEnds</strong>, which must be the serialized TCP/IP
address, including port number, that the prospective member listens on</li>
<li>and finally <strong>DigSig</strong>, the RSA/SHA1 digital signature over each of
the preceding fields, in order</li>
</ul>

<p>Note that the ClientID should <strong>not</strong> be included in the token; it is
assigned by the server in response to this message.</p>

<h3>OK Message</h3>

<p>The server examines the client message on receipt.  If the message is
ill-formed, the server simply closes the connection and discards the message.
Otherwise it determines the value of the <strong>Attrs</strong> field for the client
(currently it just accepts the client&rsquo;s proposed value and returns it)
and constructs a unique random ID for the client.  This is a
256-bit / 32-byte <strong>ClientID</strong>.  The AES-encrypted reply to the client
contains both of these fields.</p>

<ul>
<li><strong>ClientID</strong>, a 32-byte byte array</li>
<li><strong>Attrs</strong>, an unsigned 64-bit int</li>
</ul>

<h2>Create and CreateReply</h2>

<p>The Create/CreateReply sequence is necessary only if the cluster does not
already exist.</p>

<p>The client creating the cluster need not be one of the members.  It is
in fact convenient to use a dedicated admin client to create the cluster.</p>

<h3>Create Message</h3>

<p>A cluster definition must be sent to the registry for each cluster
once and only once.  A second cluster definition with the name of an
existing cluster will be rejected by the server, which will reply
with an XLReg Error message rather than a CreateReply.</p>

<p>The cluster Create message consists of</p>

<ul>
<li><strong>ClusterName</strong>, which should be an acceptable xlReg name, and so
begin with a letter (<code>[a-zA-Z_]</code>) and otherwise alphanumeric
(<code>[a-zA-Z_0-9\</code>).</li>
<li><strong>ClusterAttrs</strong>, an unsigned 64-bit integer, which currently is ignored</li>
<li><strong>ClusterSize</strong>, the maximum number of members in the cluster; this is
a 32-bit integer constrained to be in the range 1..64 inclusive</li>
<li><strong>EndPointCount</strong>, which in the current implementation should be 1 or 2</li>
</ul>

<p>The cluster name must not already be in use. If it is, the server will
reply with an error message and close the connection.</p>

<p>The <code>EndPointCount</code> is the number of endpoints that each cluster member
must have.  A member must listen on each address/port number listed.
Conventionally <code>endPoint[0]</code> is used for intra-cluster communications,
communications between cluster members, and <code>endPoint[1]</code>, if defined,
is used by clients to reach cluster members.</p>

<h3>CreateReply Message</h3>

<p>The <code>CreateReply</code> message is sent by the server to the client to confirm
cluster attributes.  It consists of</p>

<ul>
<li><strong>ClusterID</strong>, wich is assigned by the server</li>
<li>** ClusterSize***, the maximum number of members, which may have been
adjusted by the server</li>
<li><strong>EndPointCount</strong>*, which also is subject to change by the server</li>
</ul>

<h3>Error Message</h3>

<p>In the current implementation this message has a single field, an
<code>ErrDesc</code> string.  If the server sends the client an error message,
it then closes the connection.</p>

<h2>Join and JoinReply</h2>

<h3>Join Message</h3>

<p>In the current implementation a Join message has only a single field,
<code>ClusterName</code>, a string.  If the cluster exists and few members have
joined than the cluster size, the xlReg server will sdnd a JoinReply
message.  Otherwise, the server will send an error message and close
the connection.</p>

<h3>JoinReply Message</h3>

<p>If a Join request succeeds, the server responds with a JoinReply
containing:</p>

<ul>
<li>the <strong>EndPointCount</strong>, a possibly adjusted endPoint count and</li>
<li><strong>ClusterID</strong>, the usual 256-bit binary value</li>
</ul>

<p>This is the point at which prospective members knowing only the
cluster name will have learned the cluster ID.</p>

<h2>GetCluster and ClusterMembers</h2>

<p>A client sends the xlReg server GetCluster messages until it has
information on all members or until some limit (MAX_GET in the Go code)
has been exceeded.  The client does not have to be a member in order
to make this request.</p>

<h3>GetCluster Message</h3>

<p>The message has two fields:</p>

<ul>
<li><strong>ClusterID</strong>, the 32-byte cluster ID, and</li>
<li><strong>Which</strong>, a bit map identifying which members information is needed about</li>
</ul>

<p>The bit map is a little-endian sequence of 64 bits, with the low-order
bits in each byte mapping to 0, 1, 2, and so forth.  The server ignores
any bits that are out of range, so <code>0xffffffff</code> simply means &ldquo;all members&rdquo;.
The client maintains a local bit map identifying those members that it
has information on.  It will loop until it has information on all members
or until MAX_GET is exceeded.</p>

<h3>ClusterMembers Message</h3>

<p>The xlReg server replies to the GetCluster message with a ClusterMembers
message consisting of</p>

<ul>
<li><strong>ClusterID</strong>, the usual 256-bit cluster identifier</li>
<li><strong>Which</strong>, a bit map identifying which members the message contains
information about, and</li>
<li><strong>Tokens</strong>, an array of tokens as described above under the Client
Message heading</li>
</ul>

<p>The tokens are in the same order as bits in the bit map, so the client
iterates through the bit map and copies each token to the corresponding
slot in its own members table.</p>

<p>If a cluster member is making this request &ndash; that is, if the client has
already joined the cluster &ndash; the reply will normally contain a token
for the requesting client.</p>

<p>The xlReg server does not maintain state regarding which membership
information the client has collected.  If asked repeatedly for the same
information, it will send the information to the client repeatedly.</p>

<h2>Bye and Ack</h2>

<h3>Bye Message</h3>

<p>The <strong>Bye</strong> is sent by the client to signal that the session is over.
It contains no further information.</p>

<h3>Ack Message</h3>

<p>The server&rsquo;s reply is a simple <strong>Ack</strong>.  It contains no further
information.  After sending it, the server closes the connection.  On
receiving an the Ack, the client does the same.</p>
  <div class="f">
    <hr />
    <div class="license">
      <p><a href="LICENSE.html">SOFTWARE LICENSE</a></p>
    </div>
    <div class="project">
      github <a href="https://github.com/jddixon/xlReg_protocol">      <img src="img/GitHub-Mark-32px.png" 
        alt="link to project"  
        style="display: inline-block; margin-left: 0 auto; margin-right: 0 auto">
       </a> project
    </div>
    <div class="logo" >
      <a href="https://jddixon.github.io/xlattice/">
      <img src="img/xlattice-2014.jpg" alt="the XLattice Project" style="float: right;" >
      </a>
    </div>
  </div>
</div>
</body>
</html>
