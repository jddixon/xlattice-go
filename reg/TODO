xlattice_go/reg/TODO

2013-12-05
    * ClusterMember has no NewClusterMember() function BUT it has		* DONE
        a Members []*MemberInfo SLICE which must be initialized		    * DONE
        - fix was to initialize slice in NewClientNode()		        * DONE

    * UserClient.Run() may return error, especially EOF, in which case
        we need to try again; using code needs to be fixed

2013-12-04
    * reduce minimum membership to 1                                    * DONE
    * later: restore this to what it was !

2013-12-01
    * xlReg fails in upax_go tests occasionally for no obvious reason: 
        need to locate and fix bug
        - at least sometimes appears as nil nodeID pointer 
            * we have asked for a nodeID and didn't get one

2013-11-22
    * modify client_node.go to use SetupSessionKey()
    * insofar as possible, ClientNode.SessionSetup() should
        migrate to AesCnxHandler.InitSessionSetup()
    * insofar as possible, InHandler.handleHello() should 
        migrate to AesCnxHandler.ReceiverSessionSetup()
    * consider migrating to another package
        - aes_cnx.go
        - msg.ServerDecodeHello()
        - msg.ServerEncodeHelloReply()
    * the other package could be protocol/aescnx/, but the code must
        be stable and usable externally
    * cnx initializer / receiver distinction must be made very clear
        and the code (re)structured accordingly
    * XXX the problem is the protobuf protocol, which will vary from
        application to application 
        - need at least proto.Unmarshal and proto.Marshal functions
        - don't know cost of using interface{} instead of eg *XLRegMsg
        - alternative is to build a code generator; need not be in Go
        - it's acceptable in the short term to simply copy and edit
            the code in xlattice_go/reg
        - tentively 
            xlattice_go/protocol/AesCnxHandlerGen -s NAME -l LONGNAME
            where NAME/LONGNAME is that of the protocol

2013-11-18
    * add SelfIndex identifying owning node to ClusterMember            * DONE

    * this introduced a bug not caught here; need to modify tests
        to catch it

2013-11-05
    * Registry is logging EOFs on all client connections; this
        should be dropped

2013-11-04
    * xlReg should log all interactions
        - cluster joins
    * logging should be in separate goroutines and should include at
        least the IP address and port number at the far end of the
        connection (to gather enough information for blacklisting
        where appropriate)
    * xlReg is dying at seemingly random intervals; need to log errors
        where possible
        - "fatal I/O error accept tcp ...: use of closed network
            connection, shutting down the server"
        - ignoring this in tests results in infinite loop 
            * it appears to be the acceptor (the listening socket)
                which is closed, so ignoring it is impossible
            * we are in fact using the close() to shut down the server,
                so it makes no sense at all to ignore this particular
                error.
            * so need to determine which end of the connection is 
                closed and respond accordingly (far end: who cares?
                this end: we are done)

2013-11-02
    * connections to xlReg are being left open; the server should
        close

2013-10-31
    * need to properly implement 10-02 Registry-related items 
    * when ParseRegistry is available, code must be available which
        rebuilds volatile data structures, including ClustersByName
        and ClustersByID
        - in particular, the registry ID and all cluster IDs must be 
            in the registry Bloom filter

2013-10-28
    * (from 10-17) xlReg starting for the first time should
        - writes regCred to the log 

2013-10-25
    * drop options.Ephemeral, which is implied by empty backing
        file name ?
2013-10-18
    * Whatever is using BadVersion should be using the DecimalVersion
        type
        - This is in reg/in_handler.go init() and references VERSION in
            const.go.  

2013-10-17
    * determine what LFS is being used and whether the node is
        being serialized to LFS/.xlattice/node.config

2013-10-17
    * NewSoloClient needs mode parameter which is ORed into default
        0600 on LFS/.lattice/node.config

    * FIX: InHandler.doCreateMsg() treatment of existing clusters
        doesn't make any sense

    REGISTRY SERVER
    * (longer run) verify that xlReg can be configured to listen on
        either ALL IP addresses or on more than one IP address,
        such as {192.168.152.10.44444, 192.168.136.10.44444}
    * add RegCred message, which of course can't be used without
        knowing the registry's comms public key

    * ephemeral admin client unique ID should be itself ephemeral 

    UTILITIES
    * xlClusterReg -e -s K -o FILE CLUSTER_NAME -p PERM
        where K is cluster size, FILE defaults to ./reg.cred
    * xlRegCred -o FILE IP_ADDR:PORT
        where FILE defaults to ./cluster.cred, PERM to 0640
        utility which retrieves regCred, displays and/or
        writes to LFS/.xlattice/reg.cred perm 0444

2013-10-13
    * ClientNode must be able to read config from LFS
    * CHANGE Client/ClientOK to expect either
        - token without name but with digSig OR
        - clientID plus digSig
    *ClientNode Node is created after keys are created and ID is known

2013-10-12
    * need clear decision: does UserClient get clusterName?
    * use BloomSHA to handle registry ID map?  about 300 SLOC
        in Java (as implemented in xlattice_j)

2013-10-11
    * msg_handlers doClientMsg about line 70 sets all generated
        IDs to 32 bytes (SHA3)
    * doClientMsg assigns an ID if nil but just uses the SHA3
        of ckPriv and skPriv; need to add some randomness!
    * server must guarantee uniqueness of all IDs, including
        - unique clientID (both user and admin)
        - unique clusterID
    * so registry must have a map of all IDs used

2013-10-10
    * msg_handlers.go doClientMsg: change to either
        - accept ID, which must be known, plus digsig
        - or to accept token without ID plus digsig
            * in this case it generates a new and unique ID
        - old tests must continue to run at least until new
            code is stable

2013-10-09
    PROTOCOL
    * ClientMsg is EITHER token without clientID OR clientID;
        in either case plus a digital signature

2013-10-03
    * verify that mock_server_test considers it an error when
        not all members are returned

2013-10-02
    CLIENT, MOCK_CLIENT
    * change protocol so that nodeID is assigned by server (to
        avoid Douceur's Sybil Attack)
        - so first variant of Client message has token + digSig
            * without clientID in token
                - any client ID is ignored and discarded
                - which will cause digSig to be wrong
        - second version of Client message has only clientID + digSig
        - either attaches client's full token to the connection
            * this includes nodeID
    * code up the usual serialization/deserialization
        * ParseClient
        * Client.String()
        * Client.Strings()
        * Client.Run()
    * when a Client is run,
        - if it has a configuration in its lfs, it loads = does a
            ParseClient on its configuration file; this returns
            a Client with a *xn.Node field
        - otherwise it starts talking to the server (does a
            Hello/Reply to get a session key) and then sends a
            Client message without a nodeID; the nodeID returned
            is used to build its *xn.Node
    * if testing (-T option), default lfs is ./tmp/ID/lfs, where
        ID is the hex version of the server-assigned ID
    * otherwise default lfs is ./lfs
        - so there is one obvious configuration file in a subdirectory
            of the current directory

    SERVER, CLIENT/SERVER MESSAGING
    * it must be possible for a Client to create a Cluster (by name)    * DONE
        and set its size without joining it
        - ah: it must be possible for a Client to create a Cluster
            without a name and get its assigned name and ID back
    * equally it must be possible for a client to join a cluster        * DONE
        using its name and get its ID back
        - but if its full the client gets a ClusterFull error msg

    * code up Registry serialization in reg/registry.go:
        - ParseRegistry()
        - String()
        - Strings()

    * code up RegServer bits in reg/server.go:
        - ParseRegServer()
        - String()
        - Strings()

    * any errors found by InHandler should be logged

2013-10-01
    * need locking for reg_cluster Members
        - checking whether client is cluster member by ID (read lock)
    * registry RegMembersByID should be dropped or used; if used
        - when members added to clusters
            * must read lock reg and check reg.RegMembersByID
            * must write lock when adding
        - but need to decide whether this is useful
            * and whether the intention is to prevent clients from
                belonging to more than one cluster (why??)
    * when this is running, drop into ../cmd/xlReg/xlReg

2013-09-30
    * xlReg 0.2.0 must have lfs, logging, load/save
    * deploy xlReg 0.2.0 on salinas:55555
2013-09-29
    * improve RegCluster.AddMember handling of dupe names
2013-09-24
    * packets.go readData should handle partial reads, looping on count
        until all bytes have been received
    * packets.go writeData should handle partial writes, looping on count
        until all bytes have gone
2013-09-20
    * several tests could obviously benefit from parallelizing:
        they run one CPU at 100% while the others are more or less idle
        - look at cluster_member_test
        - also reg_cluster_test
2013-09-16
    * regNode serialization follows practice in ../node: we first       * DONE
        serialize BaseNode, then rest of Node, then fields of           * DONE
        RegNode                                                         * DONE
        - need Strings(), String(), Parse()                             * DONE
2013-09-13
    * URGENT FIX: ClientMsg does NOT include digsig, so server cannot
        verify that the client knows skPriv
    * longer term xlReg needs to be distributed, using Paxos for
        consensus
2013-09-12
    * build and thoroughly test ../cmd/xlReg
    * this stays on main branch
    * deploy on test:44444 as service

    * on regBeta branch figure out how to persist the registry in
        such a way it easily loads itself from disk after a
        crash or reboot
    * when this is stable, merge back into main branch
        - and deploy on test:44444
    * document
