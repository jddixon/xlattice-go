xlattice_go/reg/TODO

2013-10-28
    * "mapping file too small" error on starting xlReg, although
        file size seemed correct
        - change to 'backing file' for consistency
    * (from 10-17) xlReg starting for the first time should
        - writes regCred to the log 
    * and to its own LFS/reg.cred                                       * DONE

2013-10-27
    * booting server writes regCred.dat to its LFS                      * DONE
2013-10-25
    * drop options.Ephemeral, which is implied by empty backing
        file name ?
    * use BloomSHAI interface to let NewRegistry() create               * DONE
        appropriate type of BloomFilter (Mapped or not) depending       * DONE
        upon whether backingFile has empty name                         * DONE
2013-10-18
    * Whatever is using BadVersion should be using the DecimalVersion
        type
        - This is in reg/in_handler.go init() and references VERSION in
            const.go.  
        - That VERSION should be explicitly of type xu.DecimalVersion;  * DROP
            VERSION_DATE could also be typed.                           * DROP
            * VERSION is a string; DecimalVersion.Parse() translates
        - Note that VERSION is 0.1.1 in that file.                      * FIXED

2013-10-17
    * FIX: eph_server_test failure about line 126 suggests that Node    * FIXED
        is not being written back into ClientNode                       * FIXED
    * determine what LFS is being used and whether the node is
        being serialized to LFS/.xlattice/node.config

2013-10-17
    * NewSoloClient needs mode parameter which is ORed into default
        0600 on LFS/.lattice/node.config

    * FIX: InHandler.doCreateMsg() treatment of existing clusters
        doesn't make any sense

    REGISTRY SERVER
    * (short run) verify that xlReg can set a specifc IP address        * DONE
        to listen on, such as 192.168.152.10:44444                      * DONE
    * (longer run) verify that xlReg can be configured to listen on
        either ALL IP addresses or on more than one IP address,
        such as {192.168.152.10.44444, 192.168.136.10.44444}
    * add RegCred message, which of course can't be used without
        knowing the registry's comms public key
    * need RegCred data type with String() and Parse() methods          * DONE

    * a new server's first act is to create its own NodeID and          * DONE
        register it                                                     * DONE

    * ephemeral admin client unique ID should be itself ephemeral 

    UTILITIES
    * xlClusterReg -e -s K -o FILE CLUSTER_NAME -p PERM
        where K is cluster size, FILE defaults to ./reg.cred
    * xlRegCred -o FILE IP_ADDR:PORT
        where FILE defaults to ./cluster.cred, PERM to 0640
        utility which retrieves regCred, displays and/or
        writes to LFS/.xlattice/reg.cred perm 0444

2013-10-15
    BLOOM FILTERS                                   
    * integrate Bloom filter, to be referenced wherever IDs are         * DONE
        assigned                                                        * DONE
        - RegNode itself has an ID                                      * DONE
        - all clients have IDs                                          * DONE
        - all clusters have IDs                                         * DONE

2013-10-13
    * ClientNode must be able to read config from LFS
    * CHANGE Client/ClientOK to expect either
        - token without name but with digSig OR
        - clientID plus digSig
    *ClientNode Node is created after keys are created and ID is known

2013-10-12
    * need clear decision: does UserClient get clusterName?
    * use BloomSHA to handle registry ID map?  about 300 SLOC
        in Java (as implemented in xlattice_j)

2013-10-11
    * msg_handlers doClientMsg about line 70 sets all generated
        IDs to 32 bytes (SHA3)
    * doClientMsg assigns an ID if nil but just uses the SHA3
        of ckPriv and skPriv; need to add some randomness!
    * server must guarantee uniqueness of all IDs, including
        - unique clientID (both user and admin)
        - unique clusterID
    * so registry must have a map of all IDs used

2013-10-10
    * msg_handlers.go doClientMsg: change to either
        - accept ID, which must be known, plus digsig
        - or to accept token without ID plus digsig
            * in this case it generates a new and unique ID
        - old tests must continue to run at least until new
            code is stable

2013-10-09
    PROTOCOL
    * ClientMsg is EITHER token without clientID OR clientID;
        in either case plus a digital signature

2013-10-03
    * verify that mock_server_test considers it an error when
        not all members are returned

2013-10-02
    CLIENT, MOCK_CLIENT
    * change protocol so that nodeID is assigned by server (to
        avoid Douceur's Sybil Attack)
        - so first variant of Client message has token + digSig
            * without clientID in token
                - any client ID is ignored and discarded
                - which will cause digSig to be wrong
        - second version of Client message has only clientID + digSig
        - either attaches client's full token to the connection
            * this includes nodeID
    * code up the usual serialization/deserialization
        * ParseClient
        * Client.String()
        * Client.Strings()
        * Client.Run()
    * when a Client is run,
        - if it has a configuration in its lfs, it loads = does a
            ParseClient on its configuration file; this returns
            a Client with a *xn.Node field
        - otherwise it starts talking to the server (does a
            Hello/Reply to get a session key) and then sends a
            Client message without a nodeID; the nodeID returned
            is used to build its *xn.Node
    * if testing (-T option), default lfs is ./tmp/ID/lfs, where
        ID is the hex version of the server-assigned ID
    * otherwise default lfs is ./lfs
        - so there is one obvious configuration file in a subdirectory
            of the current directory

    SERVER, CLIENT/SERVER MESSAGING
    * it must be possible for a Client to create a Cluster (by name)    * DONE
        and set its size without joining it
        - ah: it must be possible for a Client to create a Cluster
            without a name and get its assigned name and ID back
    * equally it must be possible for a client to join a cluster        * DONE
        using its name and get its ID back
        - but if its full the client gets a ClusterFull error msg

    * code up Registry serialization in reg/registry.go:
        - ParseRegistry()
        - String()
        - Strings()

    * code up RegServer bits in reg/server.go:
        - ParseRegServer()
        - String()
        - Strings()

    * any errors found by InHandler should be logged

2013-10-01
    * need locking for reg_cluster Members
        - checking whether client is cluster member by ID (read lock)
    * registry RegMembersByID should be dropped or used; if used
        - when members added to clusters
            * must read lock reg and check reg.RegMembersByID
            * must write lock when adding
        - but need to decide whether this is useful
            * and whether the intention is to prevent clients from
                belonging to more than one cluster (why??)
    * when this is running, drop into ../cmd/xlReg/xlReg

2013-09-30
    * xlReg 0.2.0 must have lfs, logging, load/save
    * deploy xlReg 0.2.0 on salinas:55555
2013-09-29
    * improve RegCluster.AddMember handling of dupe names
2013-09-24
    * packets.go readData should handle partial reads, looping on count
        until all bytes have been received
    * packets.go writeData should handle partial writes, looping on count
        until all bytes have gone
2013-09-20
    * several tests could obviously benefit from parallelizing:
        they run one CPU at 100% while the others are more or less idle
        - look at cluster_member_test
        - also reg_cluster_test
2013-09-16
    * regNode serialization follows practice in ../node: we first
        serialize BaseNode, then rest of Node, then fields of
        RegNode
        - need Strings(), String(), Parse()
2013-09-13
    * URGENT FIX: ClientMsg does NOT include digsig, so server cannot
        verify that the client knows skPriv
    * longer term xlReg needs to be distributed, using Paxos for
        consensus
2013-09-12
    * build and thoroughly test ../cmd/xlReg
    * this stays on main branch
    * deploy on test:44444 as service

    * on regBeta branch figure out how to persist the registry in
        such a way it easily loads itself from disk after a
        crash or reboot
    * when this is stable, merge back into main branch
        - and deploy on test:44444
    * document
