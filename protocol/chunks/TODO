xlattice_go/protocol/chunks/TODO

2014-03-15 (-03-09, edited again)
    * write a test chunkListAssyDisassyTest that 
        - creates tmp/ if it doesn't exist                              * DONE
        - create tmp/uDir, where 'uDir' is an unused name               * DONE
            and uDir is a UFlat; pathToU = tmp/dirName                  * DONE

        - create a testFile > (N-1) * MAX_DATA_BYTES in size, where     * DONE
            N > 3 and where the file is in pathToU/                     * DONE

        - in the course of building a ChunkList, split the file into    * DONE
            chunks stored in chunkDir                                   * DONE
        - sign and verify the ChunkList
        - use the ChunkList to create testFile2 from the chunks
        - verify that reassyU/testFile2 is identical to pathToU/testFile

2014-03-11
    * MAX_CHUNK_BYTES of 128 KB now construed to include the 			* DONE
        header, so MAX_DATA_BYTES = 128K - 80 .			                * DONE
        - in consequence the header length field (which is the data		* DONE
            length) no longer has 1 subtracted from it			        * DONE

2014-03-10
    * test and confirm that by default a message whose length is 
        less than or equsl to MAX_DATA_BYTES is converted into a 
        ChunkList with a single member.

2014-03-09 (edited 03-08)
    * implement DigiList.Sign(skPriv, subClass)
    * implement DigiList.Verify(subClass)
    * implement DigiList.String()                                       * DONE
    * implement DigiList.Parse()                                        * DONE
    * write test which round-trips dl1 -> string -> parse -> dl2

2014-02-17
    * fix: error seen once at TestChunkList, line 119: ChunkTooLong

2014-02-10
    * it is an error if chunk length is zero or > 128K; tests should    * DONE
        check both values                                               * DONE

2013-12-13
    * Serious deficiency: the digital signature in the DigiList is
        missing in the serialization.
        - The chunk hash is over header and data, so type/version,
            chunk length, chunk index, datum, and data are included
            in the chunk hash
        - DigiList hash is over sk, title, timestamp, and then the
            chunk hashes in index order.  Receiver has no way of 
            knowing the overall length of the message.
            * This can be expressed as a uint32 chunk count.

2013-12-12
    * Devise test to verify that NewChunkList() creates the same        * DONE
        chunks that would be created if NewChunk were used.             * DONE

2013-12-11
    * NewChunkList must have a filename or io.Reader parameter !!!      * DONE
    * We need a message/file hash to build the ChunkList, otherwise 	* DONE
        if the input parameter is an io.Reader, we will need to make 	* DONE
        two passes over the message, first to determine its length 	    * DONE
        and content hash, and then to chunk it.	                        * DONE
