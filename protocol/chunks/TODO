xlattice_go/protocol/chunks/TODO

2014-03-08
    * implement DigiList.Sign(skPriv, subClass
    * implement DigiList.Verify(subClass)
    * write a test that 
        - creates tmp/ if it doesn't exist
        - create tmp/chunkDir, where chunkDir is an unused name
        - creates a testFile > (N-1) * chunkSize in size, where N > 3 
            and chunkSize is say 16 KB and where the file is in 
            chunkDir/
        - split the file into chunks, building a DigiList
        - sign and verify the DigiList
        - use the DigiList to create testFile2 from the chunks
        - verify that testFile2 is identical to testFile

2014-02-17
    * fix: error seen once at TestChunkList, line 119: ChunkTooLong

2014-02-10
    * it is an error if chunk length is zero or > 128K; tests should    * DONE
        check both values                                               * DONE

2013-12-13
    * Serious deficiency: the digital signature in the DigiList is
        missing in the serialization.
        - The chunk hash is over header and data, so type/version,
            chunk length, chunk index, datum, and data are included
            in the chunk hash
        - DigiList hash is over sk, title, timestamp, and then the
            chunk hashes in index order.  Receiver has no way of 
            knowing the overall length of the message.
            * This can be expressed as a uint32 chunk count.

2013-12-12
    * Devise test to verify that NewChunkList() creates the same        * DONE
        chunks that would be created if NewChunk were used.             * DONE

2013-12-11
    * NewChunkList must have a filename or io.Reader parameter !!!      * DONE
    * We need a message/file hash to build the ChunkList, otherwise 	* DONE
        if the input parameter is an io.Reader, we will need to make 	* DONE
        two passes over the message, first to determine its length 	    * DONE
        and content hash, and then to chunk it.	                        * DONE
