# The XLReg Protocol

## Hello and Reply

All communications with the XLReg server must begin with a Hello/Reply
exchange, which verifies to the client the identity of the server and
establishes the AES IV and key used to encrypt further message 
exchanges between the XLReg server and client.

### Version Numbers

XLReg version numbers are 4-byte little-endian values.  These may be 
thought of as `a.b.c.d`, where `a`, `b`, `c`, and `d` are unsigned byte values.
`d` is the lowest value and so will appear first in wire format.  When 
serialized as strings, version numbers are conventionally written in 
big-endian form, except that if the low-order fields are all zero, only
the high-order fields appear, so `1.2.0.0` will normally be written `1.2` 
(but will appear on the wire as `0.0.2.1`.  Similarly `1.2.3.0` serializes
as `1.2.3` but appears on the wire as `0.3.2.1` and `1.2.3.4` appears on
the wire as `4.3.2.1.

### Hello

XLReg communications begin when one machine, the **client**,
sends a Hello message to another, the **server** in this context.  The
Hello message consists of 

* a 16-byte AES initialization vector (IV)
* a 32-byte AES key
* an 8 byte salt (random value)
* a 4-byte little-endian version number

AES is a block cipher used for high speed encryption.  AES has a standard
block size of 16 bytes.  The key is a whole number of such blocks.  The IV is
used to set up cipher-block chaining (CBC), a mode of operation in which
each block of plaintext is XORed with the previous block of ciphertext 
before encryption.  The first block of plaintext has no previous block 
of ciphertext, so an IV is used instead.

Clients should encrypt the message using RSA-OAEP, SHA1, and a 20-byte
random value, the oaepSalt.  No label is used.  In Go this is done using

	ciphertext,err = rsa.EncryptOAEP(sha, oaepSalt, ck, data, nil)

where `sha` represents an instance of the SHA1 hash function and `ck` is
an RSA public key.

In production all of the random values (IV, key, salt, and oaepSalt) 
should be generated using a 
secure, crypto-quality random number generator.

The Hello message is encrypted using **the server's** public key.
The message to be encoded must not be longer than the length of modulus 
less twice the hash length plus 2.  As we use SHA1 the hash length is 
20 bytes, so for a 1024-bit = 128 byte RSA key the maximum message length
is 

	128 - (2 * 20 + 2) = 86 bytes

The hello message is 60 bytes long and so fits.  We recommend using 1024-bit
RSA keys for testing but 2048-bit or larger in production.

The Hello message is sent to the server over a TCP connection using its 
well-known address.  Conventionally the xlReg server listens on port 55555.

### Reply

The server decrypts the message using its private key - and the 
server's correctly encrypted reply proves to
the client that the server has that private key.  The server examines 
the message on receipt; 
if it is not well-formed the server silently discards it.  Otherwise the
server encrypts its reply using the AES IV and key from the Hello message.  
The server's reply consists of 

* iv2, the 16-byte IV to be used in further communications
* key2, the 32-byte AES key to be used in such communications
* salt2, an 8-byte random value
* salt1, the salt from the Hello message
* version2, a 4-byte little endian value

The first three fields should be generated by a secure random number generator.

The version number in the Hello message is a _proposed_ version number, 
the version preferred by the client.  The server will reply with the
version number that it prefers, and this is the protocol version that
will be used in subsequent messages.  In this implementation the server
simply ignores the version proposed by the client.

If the reply from the server cannot be decoded, or if salt1 does not
match the value in the Hello message, the client should silently close
the connection.

Otherwise iv2 and key2 will be used in further messages between this 
client and server.

## Registry Credentials

Any XLReg server will profide credentials upon request.  
These are conventionally delivered as an ASCII file, `regCred.dat`,
containing

* the registry's name
* its ID as a string of hex digits
* its comms RSA public key in ssh format
* its sig RSA public key in ssh format
* its IP address and port
* and the xlReg protocol version it is running.

An example follows.

<pre><code>
regCred {
    Name: xlReg
    ID: fc394d1363ce32e4cc6ae5e019bcc78176ad425014b01e906f8887eccb116664
    A
    CommsPubKey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC1gaYZ9LtXq9uBeiP0jU6kqZrekd8GLdPMhENDmkxAoulh2+74WYN7AUo38hNZNjBT3VanMwZ2+QZNTfioNFbJnEdB5DvaC+/nSQ4B2i7qBdb2fWjXfLNAreB0R+oMWigFmUzooz5kQyk3jJZLxIoSLSDlyVUO2DWp2GDVU9FE2aVod3P7I8rI83OhU2K8/lrKBuLfQsVff+AJNCleu6raMNVzLgfCNsEKC9avXovX2qGhvZdQY/KZ7ZzrvIkOq03DJ3x6Vv37pCzRJtmxX04mk2CGTtqzliuzdarIVe+tvBbtE9dTRR9L8v2LKIhAr8JF+A3SPRPbcZJTxxsri+bR

    SigPubKey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCeUamt6heiNhIJkLQUxXjnEh1iLhvwf6Rp+f2nCoBg0l1wDBpp2Qb4WBVRCNzGlwBWp+ZPd8YOGYBfqrhlkl/TPZ3xgm1IEbJ0Gh+TO8h1TlF/5zzIIrbdy5//jESad5Q3Cq2Ph7b+MH1W3tvdIWTQ24ht4qDWq0pjs8oV4fbcrNgnDCYjG5QqhTOHPRQ1ZZOLEH6p74BU+afweMimnFDYKjaQA1N328eT6gT6QeenesYy2at9Gkz0KHpE8AmpMTfk9KtjtH0HEMzaaH0+AsEF9fuAMR9B+w/HhlyRHeJYwZncVRFl1ELNZE51Th6S0BaXCJrEVqm7vaBDeKSe2Hrn

    EndPoints {
         TcpEndPoint: 127.0.0.1:44444
    }
    Version: 0.2.1
}
</code></pre>

This particular registry is on the test machine (_localhost_, `127.0.0.1`) and
listens on `44444`, the port conventionally used for xlReg testing.

The `Go` version of the xlReg client provides functions to read and write
serialized RegCred files (`xlattice_go.reg.ParseRegCred()` and
`xlattice_go.reg.String()` respectively.

## The Role of Protocol Buffers

All xlReg client-server sessions must begin with a Hello/Reply sequence, 
which establishes the identify of the server and determines the AES IV 
and key used to encrypt all further messages in the session.  While the
Hello/Reply sequence is specified in terms of a pattern of bits on the
wire, ClientMsg and OKMsg are specified by a 
[Google Protocol Buffers](http://code.google.com/p/protobuf)
protocol description file, `p.proto`.  This is used to generate libraries 
specific to the particular language.  

Any particular XLRegMsg message is first translated into wire format 
by a Protobuf library call, then PKCS7-padded to a whole number of 
16-byte AES blocks, and then AES-encrypted using the IV and key set
during the Hello/Reply sequence.  In Go this is done by a call to
    EncodePadEncrypt(msg *XLRegMsg, engine cipeher.BlockMode)
which returns either a byte slice or an error.  

The receiver inverts this process.  It gets a byte slice off the wire
and makes a call to 
    DecryptUnpadDecode(ciphertext []byte, engine cipher.BlockMode) 
which returns either a pointer to an XLRegMsg or an error.

## XLReg Protobuf Protocol Description

[xlReg Protobuf protocol](xlReg_protobuf.html)

## Client and OK

The ClientMsg, like all other XLRegMsg types, can only be sent to 
the server after AES encryption is set up by the Hello/Reply sequnce.
The message descriptions that follow are expressed in terms of the
Protobuf message spec.

### Client Message

The formal spec provides two versions of the Client message, one 
containing a Token and the other only the ClientID.  At this time
only the token-based message should be used.

The token embedded in the client message consists of

* the client **Name**, whose leading character should be a letter; other 
  characters should be alphanumeric
* an unsigned 64-bit **Attrs** field; this is the client's proposed 
  value (and is ignored in the current implementation)
* a serialized RSA public key, the **CommsKey**, used for encrypting 
  (small) messages
* another serialzied RSA public key, the **SigKey**, used only for
  creating digital signatures
* an array of strings, **MyEnds**, which must be the serialized TCP/IP
  address, including port number, that the prospective member listens on
* and finally **DigSig**, the RSA/SHA1 digital signature over each of 
  the preceding fields, in order

Note that the ClientID should **not** be included in the token; it is
assigned by the server in response to this message.

### OK Message

The server examines the client message on receipt.  If the message is
ill-formed, the server simply closes the connection and discards the message.
Otherwise it determines the value of the **Attrs** field for the client
(currently it just accepts the client's proposed value) constructs a unique 
random ID for the client.  This is a 256-bit / 32-byte **ClientID**.  
The AES-encrypted reply to the client contains both of these fields.

* **ClientID**, a 32-byte byte array 
* **Attrs**, an unsigned 64-bit int

## Create and CreateReply

The Create/CreateReply sequence is necessary only if the cluster does not
already exist.  

### Create Message

A cluster definition must be sent to the registry for each cluster
once and only once.  A second cluster definition with the name of an
existing cluster will be rejected by the server, which will reply
with an XLReg Error message rather than a CreateReply.

The cluster Create message consists of 

*  **ClusterName**, which should be an acceptable xlReg name, and so 
   begin with a letter (`[a-zA-Z_]`) and otherwise alphanumeric 
   (`[a-zA-Z_0-9\`).
* **ClusterAttrs**, an unsigned 64-bit integer, which currently is ignored
* **ClusterSize**, the maximum number of members in the cluster; this is
  a 32-bit integer constrained to be in the range 1..64 inclusive
* **EndPointCount**, which in the current implementation should be 1 or 2

The name must not already be in use.

The `EndPointCount` is the number of endpoints that each cluster member
must have.  A member must listen on each address/port number listed.  
Conventionally `endPoint[0]` is used for intra-clusgter communications,
communications between clusgter members, and `endPoint[1]`, if defined,
is used by clients to reach clusgter members.

The client creating the cluster need not be one of the members.  It is
in fact convenient to use a dedicated admin client to create the cluster.

### CreateReply Message

The `CreateReply` message is sent by the server to the client to confirm
cluster attributes.  It consists of 

* **ClusterID**, wich is assigned by the server
* ** ClusterSize***, the maximum number of members, which may have been
  adjusted by the server
* **EndPointCount***, which also is subject to change by the server

## Join and JoinReply

### Join Message

### JoinReply Message

## GetCluster and ClusterMembers

### GetCluster Message

### ClusterMembers Message

## Bye and Ack

### Bye Message

### OK Message

## Error Message

